{"version":3,"file":"static/js/348.ed2e97ee.chunk.js","mappings":"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","sources":["services/api/scholarApi.ts"],"sourcesContent":["import { api, ensureString } from './core';\nimport { SearchResult } from './types';\n\n// 谷歌学术相关API\nexport const scholarApi = {\n  // 国内可用的谷歌学术镜像站点\n  scholarMirrors: [\n    'https://xueshu.lanfanshu.cn',\n    'https://ac.scmor.com',\n    'https://scholar.hedasudi.com',\n    'https://gg.xueshu5.com'\n  ],\n  \n  // 获取随机镜像站点\n  getRandomMirror: (): string => {\n    const mirrors = scholarApi.scholarMirrors;\n    const randomIndex = Math.floor(Math.random() * mirrors.length);\n    return mirrors[randomIndex];\n  },\n  \n  // 计算两个字符串的相似度（使用Levenshtein距离的归一化版本）\n  calculateSimilarity: (str1: string, str2: string): number => {\n    if (!str1 || !str2) return 0;\n    \n    const a = str1.toLowerCase();\n    const b = str2.toLowerCase();\n    \n    // 使用编辑距离算法\n    const matrix = [];\n    \n    // 初始化\n    for (let i = 0; i <= a.length; i++) {\n      matrix[i] = [i];\n    }\n    \n    for (let j = 0; j <= b.length; j++) {\n      matrix[0][j] = j;\n    }\n    \n    // 填充矩阵\n    for (let i = 1; i <= a.length; i++) {\n      for (let j = 1; j <= b.length; j++) {\n        if (a.charAt(i - 1) === b.charAt(j - 1)) {\n          matrix[i][j] = matrix[i - 1][j - 1];\n        } else {\n          matrix[i][j] = Math.min(\n            matrix[i - 1][j - 1] + 1, // 替换\n            matrix[i][j - 1] + 1,     // 插入\n            matrix[i - 1][j] + 1      // 删除\n          );\n        }\n      }\n    }\n    \n    // 计算相似度（1 - 归一化编辑距离）\n    const maxLen = Math.max(a.length, b.length);\n    const similarity = 1 - matrix[a.length][b.length] / maxLen;\n    \n    return similarity;\n  },\n\n  // 在谷歌学术上搜索论文\n  searchPaper: async (title: string, author?: string): Promise<SearchResult[]> => {\n    try {\n      // 构建搜索查询\n      let query = `allintitle:${title}`;\n      if (author) {\n        query += ` author:${author}`;\n      }\n      \n      // 使用后端API进行搜索，后端将使用配置的镜像站点\n      const response = await api.get('/api/search/scholar', {\n        params: { q: query },\n        timeout: 30000 // 30秒超时\n      });\n      \n      // 处理返回数据\n      if (response.data && response.data.results) {\n        // 新版API直接返回结构化数据\n        console.log('Search results:', response.data.results);\n        return response.data.results;\n      } else if (response.data && typeof response.data === 'string') {\n        // 旧版API返回HTML，需要解析\n        return scholarApi.parseSearchResults(response.data, title);\n      } else {\n        console.log('未知格式的搜索结果:', response.data);\n        return [];\n      }\n    } catch (error) {\n      console.error('Scholar search error:', error);\n      return [];\n    }\n  },\n  \n  // 解析HTML响应\n  parseSearchResults: (html: string, originalTitle: string): SearchResult[] => {\n    // 创建一个临时的DOM元素来解析HTML\n    const doc = document.implementation.createHTMLDocument('temp');\n    doc.documentElement.innerHTML = html;\n    \n    const results: SearchResult[] = [];\n    \n    // 尝试不同的选择器（因为谷歌学术的HTML结构可能发生变化）\n    const selectors = [\n      '.gs_ri', // 标准结果项\n      '.gs_r.gs_or.gs_scl', // 备用选择器1\n      '.gs_or.gs_scl' // 备用选择器2\n    ];\n    \n    let items: NodeListOf<Element> | null = null;\n    \n    // 尝试不同的选择器，直到找到结果\n    for (const selector of selectors) {\n      items = doc.querySelectorAll(selector);\n      if (items && items.length > 0) {\n        console.log(`找到选择器 ${selector} 的结果：${items.length}项`);\n        break;\n      }\n    }\n    \n    if (!items || items.length === 0) {\n      console.warn('无法在HTML中找到论文结果');\n      return [];\n    }\n    \n    // 处理每个找到的结果\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      \n      const paperInfo = scholarApi.extractPaperInfo(item, originalTitle);\n      if (paperInfo) {\n        results.push(paperInfo);\n      }\n    }\n    \n    // 不再按相似度排序，直接返回结果\n    return results;\n  },\n  \n  // 从搜索结果中提取论文信息\n  extractPaperInfo: (item: Element, originalTitle: string): SearchResult | null => {\n    try {\n      // 尝试获取标题元素\n      const titleEl = item.querySelector('.gs_rt a, .gs_rti a') || \n                     item.querySelector('[data-lid]') ||\n                     item.querySelector('h3 a');\n      \n      if (!titleEl) {\n        return null;\n      }\n      \n      const title = ensureString(titleEl.textContent).trim();\n      const link = ensureString(titleEl.getAttribute('href'));\n      \n      // 尝试获取摘要\n      const abstractEl = item.querySelector('.gs_rs') || \n                        item.querySelector('.gs_fl') || \n                        item.querySelector('.gs_snippet');\n      const abstract = abstractEl ? ensureString(abstractEl.textContent).trim() : '';\n      \n      // 尝试获取作者、期刊、年份信息\n      const infoEl = item.querySelector('.gs_a') || \n                    item.querySelector('.gs_fl');\n      const info = infoEl ? ensureString(infoEl.textContent).trim() : '';\n      \n      // 尝试解析DOI\n      let doi = '';\n      \n      // 方法1：从文本中查找DOI\n      const doiMatch = abstract.match(/10\\.\\d{4,9}\\/[-._;()/:A-Z0-9]+/i) || \n                      info.match(/10\\.\\d{4,9}\\/[-._;()/:A-Z0-9]+/i);\n      \n      if (doiMatch) {\n        doi = doiMatch[0];\n      }\n      \n      // 方法2：查找外部链接中的DOI\n      if (!doi) {\n        const links = item.querySelectorAll('a');\n        for (let i = 0; i < links.length; i++) {\n          const href = links[i].getAttribute('href') || '';\n          const doiLinkMatch = href.match(/10\\.\\d{4,9}\\/[-._;()/:A-Z0-9]+/i);\n          if (doiLinkMatch) {\n            doi = doiLinkMatch[0];\n            break;\n          }\n        }\n      }\n      \n      // 计算标题相似度\n      const similarity = scholarApi.calculateSimilarity(title, originalTitle);\n      \n      return {\n        id: Math.random(), // 生成一个随机ID\n        title,\n        authors: [], // 从info解析作者，但这里简化处理\n        year: 0, // 这里应该从info中解析，但简化处理\n        journal: info,\n        abstract,\n        doi,\n        url: link,\n        source: 'scholar'\n      };\n    } catch (error) {\n      console.error('提取论文信息时出错:', error);\n      return null;\n    }\n  },\n\n  getProfile: async (name: string) => {\n    const response = await api.get(`/api/scholar/${name}`);\n    return response.data;\n  }\n}; "],"names":["scholarApi","scholarMirrors","getRandomMirror","mirrors","Math","floor","random","length","calculateSimilarity","str1","str2","a","toLowerCase","b","matrix","i","j","charAt","min","maxLen","max","searchPaper","async","title","author","query","response","api","get","params","q","timeout","data","results","console","log","parseSearchResults","error","html","originalTitle","doc","document","implementation","createHTMLDocument","documentElement","innerHTML","selectors","items","selector","querySelectorAll","warn","item","paperInfo","extractPaperInfo","push","titleEl","querySelector","ensureString","textContent","trim","link","getAttribute","abstractEl","abstract","infoEl","info","doi","doiMatch","match","links","doiLinkMatch","id","authors","year","journal","url","source","getProfile","name"],"sourceRoot":""}